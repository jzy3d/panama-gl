// Generated by jextract

package opengl.windows.v10;

import java.lang.invoke.MethodHandle;
import java.lang.invoke.VarHandle;
import java.nio.ByteOrder;
import jdk.incubator.foreign.*;
import static jdk.incubator.foreign.ValueLayout.*;
public class _SYSTEM_POWER_POLICY {

    static final  GroupLayout $struct$LAYOUT = MemoryLayout.structLayout(
        Constants$root.C_LONG$LAYOUT.withName("Revision"),
        MemoryLayout.structLayout(
            Constants$root.C_LONG$LAYOUT.withName("Action"),
            Constants$root.C_LONG$LAYOUT.withName("Flags"),
            Constants$root.C_LONG$LAYOUT.withName("EventCode")
        ).withName("PowerButton"),
        MemoryLayout.structLayout(
            Constants$root.C_LONG$LAYOUT.withName("Action"),
            Constants$root.C_LONG$LAYOUT.withName("Flags"),
            Constants$root.C_LONG$LAYOUT.withName("EventCode")
        ).withName("SleepButton"),
        MemoryLayout.structLayout(
            Constants$root.C_LONG$LAYOUT.withName("Action"),
            Constants$root.C_LONG$LAYOUT.withName("Flags"),
            Constants$root.C_LONG$LAYOUT.withName("EventCode")
        ).withName("LidClose"),
        Constants$root.C_LONG$LAYOUT.withName("LidOpenWake"),
        Constants$root.C_LONG$LAYOUT.withName("Reserved"),
        MemoryLayout.structLayout(
            Constants$root.C_LONG$LAYOUT.withName("Action"),
            Constants$root.C_LONG$LAYOUT.withName("Flags"),
            Constants$root.C_LONG$LAYOUT.withName("EventCode")
        ).withName("Idle"),
        Constants$root.C_LONG$LAYOUT.withName("IdleTimeout"),
        Constants$root.C_CHAR$LAYOUT.withName("IdleSensitivity"),
        Constants$root.C_CHAR$LAYOUT.withName("DynamicThrottle"),
        MemoryLayout.sequenceLayout(2, Constants$root.C_CHAR$LAYOUT).withName("Spare2"),
        Constants$root.C_LONG$LAYOUT.withName("MinSleep"),
        Constants$root.C_LONG$LAYOUT.withName("MaxSleep"),
        Constants$root.C_LONG$LAYOUT.withName("ReducedLatencySleep"),
        Constants$root.C_LONG$LAYOUT.withName("WinLogonFlags"),
        Constants$root.C_LONG$LAYOUT.withName("Spare3"),
        Constants$root.C_LONG$LAYOUT.withName("DozeS4Timeout"),
        Constants$root.C_LONG$LAYOUT.withName("BroadcastCapacityResolution"),
        MemoryLayout.sequenceLayout(4, MemoryLayout.structLayout(
            Constants$root.C_CHAR$LAYOUT.withName("Enable"),
            MemoryLayout.sequenceLayout(3, Constants$root.C_CHAR$LAYOUT).withName("Spare"),
            Constants$root.C_LONG$LAYOUT.withName("BatteryLevel"),
            MemoryLayout.structLayout(
                Constants$root.C_LONG$LAYOUT.withName("Action"),
                Constants$root.C_LONG$LAYOUT.withName("Flags"),
                Constants$root.C_LONG$LAYOUT.withName("EventCode")
            ).withName("PowerPolicy"),
            Constants$root.C_LONG$LAYOUT.withName("MinSystemState")
        )).withName("DischargePolicy"),
        Constants$root.C_LONG$LAYOUT.withName("VideoTimeout"),
        Constants$root.C_CHAR$LAYOUT.withName("VideoDimDisplay"),
        MemoryLayout.paddingLayout(24),
        MemoryLayout.sequenceLayout(3, Constants$root.C_LONG$LAYOUT).withName("VideoReserved"),
        Constants$root.C_LONG$LAYOUT.withName("SpindownTimeout"),
        Constants$root.C_CHAR$LAYOUT.withName("OptimizeForPower"),
        Constants$root.C_CHAR$LAYOUT.withName("FanThrottleTolerance"),
        Constants$root.C_CHAR$LAYOUT.withName("ForcedThrottle"),
        Constants$root.C_CHAR$LAYOUT.withName("MinThrottle"),
        MemoryLayout.structLayout(
            Constants$root.C_LONG$LAYOUT.withName("Action"),
            Constants$root.C_LONG$LAYOUT.withName("Flags"),
            Constants$root.C_LONG$LAYOUT.withName("EventCode")
        ).withName("OverThrottled")
    ).withName("_SYSTEM_POWER_POLICY");
    public static MemoryLayout $LAYOUT() {
        return _SYSTEM_POWER_POLICY.$struct$LAYOUT;
    }
    static final VarHandle Revision$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("Revision"));
    public static VarHandle Revision$VH() {
        return _SYSTEM_POWER_POLICY.Revision$VH;
    }
    public static int Revision$get(MemorySegment seg) {
        return (int)_SYSTEM_POWER_POLICY.Revision$VH.get(seg);
    }
    public static void Revision$set( MemorySegment seg, int x) {
        _SYSTEM_POWER_POLICY.Revision$VH.set(seg, x);
    }
    public static int Revision$get(MemorySegment seg, long index) {
        return (int)_SYSTEM_POWER_POLICY.Revision$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void Revision$set(MemorySegment seg, long index, int x) {
        _SYSTEM_POWER_POLICY.Revision$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static MemorySegment PowerButton$slice(MemorySegment seg) {
        return seg.asSlice(4, 12);
    }
    public static MemorySegment SleepButton$slice(MemorySegment seg) {
        return seg.asSlice(16, 12);
    }
    public static MemorySegment LidClose$slice(MemorySegment seg) {
        return seg.asSlice(28, 12);
    }
    static final VarHandle LidOpenWake$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("LidOpenWake"));
    public static VarHandle LidOpenWake$VH() {
        return _SYSTEM_POWER_POLICY.LidOpenWake$VH;
    }
    public static int LidOpenWake$get(MemorySegment seg) {
        return (int)_SYSTEM_POWER_POLICY.LidOpenWake$VH.get(seg);
    }
    public static void LidOpenWake$set( MemorySegment seg, int x) {
        _SYSTEM_POWER_POLICY.LidOpenWake$VH.set(seg, x);
    }
    public static int LidOpenWake$get(MemorySegment seg, long index) {
        return (int)_SYSTEM_POWER_POLICY.LidOpenWake$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void LidOpenWake$set(MemorySegment seg, long index, int x) {
        _SYSTEM_POWER_POLICY.LidOpenWake$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle Reserved$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("Reserved"));
    public static VarHandle Reserved$VH() {
        return _SYSTEM_POWER_POLICY.Reserved$VH;
    }
    public static int Reserved$get(MemorySegment seg) {
        return (int)_SYSTEM_POWER_POLICY.Reserved$VH.get(seg);
    }
    public static void Reserved$set( MemorySegment seg, int x) {
        _SYSTEM_POWER_POLICY.Reserved$VH.set(seg, x);
    }
    public static int Reserved$get(MemorySegment seg, long index) {
        return (int)_SYSTEM_POWER_POLICY.Reserved$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void Reserved$set(MemorySegment seg, long index, int x) {
        _SYSTEM_POWER_POLICY.Reserved$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static MemorySegment Idle$slice(MemorySegment seg) {
        return seg.asSlice(48, 12);
    }
    static final VarHandle IdleTimeout$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("IdleTimeout"));
    public static VarHandle IdleTimeout$VH() {
        return _SYSTEM_POWER_POLICY.IdleTimeout$VH;
    }
    public static int IdleTimeout$get(MemorySegment seg) {
        return (int)_SYSTEM_POWER_POLICY.IdleTimeout$VH.get(seg);
    }
    public static void IdleTimeout$set( MemorySegment seg, int x) {
        _SYSTEM_POWER_POLICY.IdleTimeout$VH.set(seg, x);
    }
    public static int IdleTimeout$get(MemorySegment seg, long index) {
        return (int)_SYSTEM_POWER_POLICY.IdleTimeout$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void IdleTimeout$set(MemorySegment seg, long index, int x) {
        _SYSTEM_POWER_POLICY.IdleTimeout$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle IdleSensitivity$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("IdleSensitivity"));
    public static VarHandle IdleSensitivity$VH() {
        return _SYSTEM_POWER_POLICY.IdleSensitivity$VH;
    }
    public static byte IdleSensitivity$get(MemorySegment seg) {
        return (byte)_SYSTEM_POWER_POLICY.IdleSensitivity$VH.get(seg);
    }
    public static void IdleSensitivity$set( MemorySegment seg, byte x) {
        _SYSTEM_POWER_POLICY.IdleSensitivity$VH.set(seg, x);
    }
    public static byte IdleSensitivity$get(MemorySegment seg, long index) {
        return (byte)_SYSTEM_POWER_POLICY.IdleSensitivity$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void IdleSensitivity$set(MemorySegment seg, long index, byte x) {
        _SYSTEM_POWER_POLICY.IdleSensitivity$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle DynamicThrottle$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("DynamicThrottle"));
    public static VarHandle DynamicThrottle$VH() {
        return _SYSTEM_POWER_POLICY.DynamicThrottle$VH;
    }
    public static byte DynamicThrottle$get(MemorySegment seg) {
        return (byte)_SYSTEM_POWER_POLICY.DynamicThrottle$VH.get(seg);
    }
    public static void DynamicThrottle$set( MemorySegment seg, byte x) {
        _SYSTEM_POWER_POLICY.DynamicThrottle$VH.set(seg, x);
    }
    public static byte DynamicThrottle$get(MemorySegment seg, long index) {
        return (byte)_SYSTEM_POWER_POLICY.DynamicThrottle$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void DynamicThrottle$set(MemorySegment seg, long index, byte x) {
        _SYSTEM_POWER_POLICY.DynamicThrottle$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static MemorySegment Spare2$slice(MemorySegment seg) {
        return seg.asSlice(66, 2);
    }
    static final VarHandle MinSleep$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("MinSleep"));
    public static VarHandle MinSleep$VH() {
        return _SYSTEM_POWER_POLICY.MinSleep$VH;
    }
    public static int MinSleep$get(MemorySegment seg) {
        return (int)_SYSTEM_POWER_POLICY.MinSleep$VH.get(seg);
    }
    public static void MinSleep$set( MemorySegment seg, int x) {
        _SYSTEM_POWER_POLICY.MinSleep$VH.set(seg, x);
    }
    public static int MinSleep$get(MemorySegment seg, long index) {
        return (int)_SYSTEM_POWER_POLICY.MinSleep$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void MinSleep$set(MemorySegment seg, long index, int x) {
        _SYSTEM_POWER_POLICY.MinSleep$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle MaxSleep$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("MaxSleep"));
    public static VarHandle MaxSleep$VH() {
        return _SYSTEM_POWER_POLICY.MaxSleep$VH;
    }
    public static int MaxSleep$get(MemorySegment seg) {
        return (int)_SYSTEM_POWER_POLICY.MaxSleep$VH.get(seg);
    }
    public static void MaxSleep$set( MemorySegment seg, int x) {
        _SYSTEM_POWER_POLICY.MaxSleep$VH.set(seg, x);
    }
    public static int MaxSleep$get(MemorySegment seg, long index) {
        return (int)_SYSTEM_POWER_POLICY.MaxSleep$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void MaxSleep$set(MemorySegment seg, long index, int x) {
        _SYSTEM_POWER_POLICY.MaxSleep$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle ReducedLatencySleep$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("ReducedLatencySleep"));
    public static VarHandle ReducedLatencySleep$VH() {
        return _SYSTEM_POWER_POLICY.ReducedLatencySleep$VH;
    }
    public static int ReducedLatencySleep$get(MemorySegment seg) {
        return (int)_SYSTEM_POWER_POLICY.ReducedLatencySleep$VH.get(seg);
    }
    public static void ReducedLatencySleep$set( MemorySegment seg, int x) {
        _SYSTEM_POWER_POLICY.ReducedLatencySleep$VH.set(seg, x);
    }
    public static int ReducedLatencySleep$get(MemorySegment seg, long index) {
        return (int)_SYSTEM_POWER_POLICY.ReducedLatencySleep$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void ReducedLatencySleep$set(MemorySegment seg, long index, int x) {
        _SYSTEM_POWER_POLICY.ReducedLatencySleep$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle WinLogonFlags$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("WinLogonFlags"));
    public static VarHandle WinLogonFlags$VH() {
        return _SYSTEM_POWER_POLICY.WinLogonFlags$VH;
    }
    public static int WinLogonFlags$get(MemorySegment seg) {
        return (int)_SYSTEM_POWER_POLICY.WinLogonFlags$VH.get(seg);
    }
    public static void WinLogonFlags$set( MemorySegment seg, int x) {
        _SYSTEM_POWER_POLICY.WinLogonFlags$VH.set(seg, x);
    }
    public static int WinLogonFlags$get(MemorySegment seg, long index) {
        return (int)_SYSTEM_POWER_POLICY.WinLogonFlags$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void WinLogonFlags$set(MemorySegment seg, long index, int x) {
        _SYSTEM_POWER_POLICY.WinLogonFlags$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle Spare3$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("Spare3"));
    public static VarHandle Spare3$VH() {
        return _SYSTEM_POWER_POLICY.Spare3$VH;
    }
    public static int Spare3$get(MemorySegment seg) {
        return (int)_SYSTEM_POWER_POLICY.Spare3$VH.get(seg);
    }
    public static void Spare3$set( MemorySegment seg, int x) {
        _SYSTEM_POWER_POLICY.Spare3$VH.set(seg, x);
    }
    public static int Spare3$get(MemorySegment seg, long index) {
        return (int)_SYSTEM_POWER_POLICY.Spare3$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void Spare3$set(MemorySegment seg, long index, int x) {
        _SYSTEM_POWER_POLICY.Spare3$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle DozeS4Timeout$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("DozeS4Timeout"));
    public static VarHandle DozeS4Timeout$VH() {
        return _SYSTEM_POWER_POLICY.DozeS4Timeout$VH;
    }
    public static int DozeS4Timeout$get(MemorySegment seg) {
        return (int)_SYSTEM_POWER_POLICY.DozeS4Timeout$VH.get(seg);
    }
    public static void DozeS4Timeout$set( MemorySegment seg, int x) {
        _SYSTEM_POWER_POLICY.DozeS4Timeout$VH.set(seg, x);
    }
    public static int DozeS4Timeout$get(MemorySegment seg, long index) {
        return (int)_SYSTEM_POWER_POLICY.DozeS4Timeout$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void DozeS4Timeout$set(MemorySegment seg, long index, int x) {
        _SYSTEM_POWER_POLICY.DozeS4Timeout$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle BroadcastCapacityResolution$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("BroadcastCapacityResolution"));
    public static VarHandle BroadcastCapacityResolution$VH() {
        return _SYSTEM_POWER_POLICY.BroadcastCapacityResolution$VH;
    }
    public static int BroadcastCapacityResolution$get(MemorySegment seg) {
        return (int)_SYSTEM_POWER_POLICY.BroadcastCapacityResolution$VH.get(seg);
    }
    public static void BroadcastCapacityResolution$set( MemorySegment seg, int x) {
        _SYSTEM_POWER_POLICY.BroadcastCapacityResolution$VH.set(seg, x);
    }
    public static int BroadcastCapacityResolution$get(MemorySegment seg, long index) {
        return (int)_SYSTEM_POWER_POLICY.BroadcastCapacityResolution$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void BroadcastCapacityResolution$set(MemorySegment seg, long index, int x) {
        _SYSTEM_POWER_POLICY.BroadcastCapacityResolution$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static MemorySegment DischargePolicy$slice(MemorySegment seg) {
        return seg.asSlice(96, 96);
    }
    static final VarHandle VideoTimeout$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("VideoTimeout"));
    public static VarHandle VideoTimeout$VH() {
        return _SYSTEM_POWER_POLICY.VideoTimeout$VH;
    }
    public static int VideoTimeout$get(MemorySegment seg) {
        return (int)_SYSTEM_POWER_POLICY.VideoTimeout$VH.get(seg);
    }
    public static void VideoTimeout$set( MemorySegment seg, int x) {
        _SYSTEM_POWER_POLICY.VideoTimeout$VH.set(seg, x);
    }
    public static int VideoTimeout$get(MemorySegment seg, long index) {
        return (int)_SYSTEM_POWER_POLICY.VideoTimeout$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void VideoTimeout$set(MemorySegment seg, long index, int x) {
        _SYSTEM_POWER_POLICY.VideoTimeout$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle VideoDimDisplay$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("VideoDimDisplay"));
    public static VarHandle VideoDimDisplay$VH() {
        return _SYSTEM_POWER_POLICY.VideoDimDisplay$VH;
    }
    public static byte VideoDimDisplay$get(MemorySegment seg) {
        return (byte)_SYSTEM_POWER_POLICY.VideoDimDisplay$VH.get(seg);
    }
    public static void VideoDimDisplay$set( MemorySegment seg, byte x) {
        _SYSTEM_POWER_POLICY.VideoDimDisplay$VH.set(seg, x);
    }
    public static byte VideoDimDisplay$get(MemorySegment seg, long index) {
        return (byte)_SYSTEM_POWER_POLICY.VideoDimDisplay$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void VideoDimDisplay$set(MemorySegment seg, long index, byte x) {
        _SYSTEM_POWER_POLICY.VideoDimDisplay$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static MemorySegment VideoReserved$slice(MemorySegment seg) {
        return seg.asSlice(200, 12);
    }
    static final VarHandle SpindownTimeout$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("SpindownTimeout"));
    public static VarHandle SpindownTimeout$VH() {
        return _SYSTEM_POWER_POLICY.SpindownTimeout$VH;
    }
    public static int SpindownTimeout$get(MemorySegment seg) {
        return (int)_SYSTEM_POWER_POLICY.SpindownTimeout$VH.get(seg);
    }
    public static void SpindownTimeout$set( MemorySegment seg, int x) {
        _SYSTEM_POWER_POLICY.SpindownTimeout$VH.set(seg, x);
    }
    public static int SpindownTimeout$get(MemorySegment seg, long index) {
        return (int)_SYSTEM_POWER_POLICY.SpindownTimeout$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void SpindownTimeout$set(MemorySegment seg, long index, int x) {
        _SYSTEM_POWER_POLICY.SpindownTimeout$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle OptimizeForPower$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("OptimizeForPower"));
    public static VarHandle OptimizeForPower$VH() {
        return _SYSTEM_POWER_POLICY.OptimizeForPower$VH;
    }
    public static byte OptimizeForPower$get(MemorySegment seg) {
        return (byte)_SYSTEM_POWER_POLICY.OptimizeForPower$VH.get(seg);
    }
    public static void OptimizeForPower$set( MemorySegment seg, byte x) {
        _SYSTEM_POWER_POLICY.OptimizeForPower$VH.set(seg, x);
    }
    public static byte OptimizeForPower$get(MemorySegment seg, long index) {
        return (byte)_SYSTEM_POWER_POLICY.OptimizeForPower$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void OptimizeForPower$set(MemorySegment seg, long index, byte x) {
        _SYSTEM_POWER_POLICY.OptimizeForPower$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle FanThrottleTolerance$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("FanThrottleTolerance"));
    public static VarHandle FanThrottleTolerance$VH() {
        return _SYSTEM_POWER_POLICY.FanThrottleTolerance$VH;
    }
    public static byte FanThrottleTolerance$get(MemorySegment seg) {
        return (byte)_SYSTEM_POWER_POLICY.FanThrottleTolerance$VH.get(seg);
    }
    public static void FanThrottleTolerance$set( MemorySegment seg, byte x) {
        _SYSTEM_POWER_POLICY.FanThrottleTolerance$VH.set(seg, x);
    }
    public static byte FanThrottleTolerance$get(MemorySegment seg, long index) {
        return (byte)_SYSTEM_POWER_POLICY.FanThrottleTolerance$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void FanThrottleTolerance$set(MemorySegment seg, long index, byte x) {
        _SYSTEM_POWER_POLICY.FanThrottleTolerance$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle ForcedThrottle$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("ForcedThrottle"));
    public static VarHandle ForcedThrottle$VH() {
        return _SYSTEM_POWER_POLICY.ForcedThrottle$VH;
    }
    public static byte ForcedThrottle$get(MemorySegment seg) {
        return (byte)_SYSTEM_POWER_POLICY.ForcedThrottle$VH.get(seg);
    }
    public static void ForcedThrottle$set( MemorySegment seg, byte x) {
        _SYSTEM_POWER_POLICY.ForcedThrottle$VH.set(seg, x);
    }
    public static byte ForcedThrottle$get(MemorySegment seg, long index) {
        return (byte)_SYSTEM_POWER_POLICY.ForcedThrottle$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void ForcedThrottle$set(MemorySegment seg, long index, byte x) {
        _SYSTEM_POWER_POLICY.ForcedThrottle$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle MinThrottle$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("MinThrottle"));
    public static VarHandle MinThrottle$VH() {
        return _SYSTEM_POWER_POLICY.MinThrottle$VH;
    }
    public static byte MinThrottle$get(MemorySegment seg) {
        return (byte)_SYSTEM_POWER_POLICY.MinThrottle$VH.get(seg);
    }
    public static void MinThrottle$set( MemorySegment seg, byte x) {
        _SYSTEM_POWER_POLICY.MinThrottle$VH.set(seg, x);
    }
    public static byte MinThrottle$get(MemorySegment seg, long index) {
        return (byte)_SYSTEM_POWER_POLICY.MinThrottle$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void MinThrottle$set(MemorySegment seg, long index, byte x) {
        _SYSTEM_POWER_POLICY.MinThrottle$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static MemorySegment OverThrottled$slice(MemorySegment seg) {
        return seg.asSlice(220, 12);
    }
    public static long sizeof() { return $LAYOUT().byteSize(); }
    public static MemorySegment allocate(SegmentAllocator allocator) { return allocator.allocate($LAYOUT()); }
    public static MemorySegment allocateArray(int len, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(len, $LAYOUT()));
    }
    public static MemorySegment allocate(ResourceScope scope) { return allocate(SegmentAllocator.nativeAllocator(scope)); }
    public static MemorySegment allocateArray(int len, ResourceScope scope) {
        return allocateArray(len, SegmentAllocator.nativeAllocator(scope));
    }
    public static MemorySegment ofAddress(MemoryAddress addr, ResourceScope scope) { return RuntimeHelper.asArray(addr, $LAYOUT(), 1, scope); }
}


